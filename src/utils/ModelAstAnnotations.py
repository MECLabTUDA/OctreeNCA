import ast, inspect, functools, textwrap
import os
from typing import List


doVisualization: bool = os.getenv("DO_VIS")
"""
Ast VIsitor. This is only used to augment the source code for the forward method in the models. This is not really necessary, 
the necessary lines can be added manually. We mainly did this in order to archieve consistency with the 'no need to manually alter any existing classes'
design principle. 
Mainly, data generated by each step has to be detached from torch and stored in the steps dict.
"""
class ModelASTTransformer(ast.NodeTransformer):
    insert_before_loop: str
    insert_first_in_loop: str
    insert_before_return: str
    augmented_function: str
    before_for_inserted: bool = False
    in_for_inserted: bool = False
    before_return_inserted: bool = False
    
    def __init__(self, augmented_function: str,  insert_before_loop: str, insert_first_in_loop: str, insert_before_return: str):
        self.insert_before_loop = insert_before_loop
        self.insert_first_in_loop = insert_first_in_loop
        self.insert_before_return = insert_before_return
        self.augmented_function = augmented_function        

    def visit_FunctionDef(self, node):
        # remove the `some_decorator` decorator from the AST
        # we donâ€™t need to keep applying it.
        if node.decorator_list:
            node.decorator_list = [
                n for n in node.decorator_list
                if not (isinstance(n, ast.Name) and n.id == 'forward_vis')
            ]
        #print(node.name)
        
        if node.name == self.augmented_function:
            stmts: List[ast.stmt]
            stmts = node.body
            st_len = len(stmts)
            i = 0
            while i < st_len:
                if isinstance(stmts[i], ast.For) and not self.before_for_inserted:
                    insert_before_for = ast.parse(self.insert_before_loop)
                    body = insert_before_for.body
                    
                    stmts[i:i] = body
                    self.before_for_inserted = True
                    st_len += len(body)
                    i += len(body)
                if isinstance(stmts[i], ast.Return)and not self.before_return_inserted:
                    insert_before_return = ast.parse(self.insert_before_return)
                    body = insert_before_return.body
                    stmts[i:i] = body
                    st_len += len(body)
                    i += len(body)
                    self.before_return_inserted = True
                i += 1
            node.body = stmts
            return self.generic_visit(node)
        
            # this should hopefully lead to only the correct function declaration being visited?????
        else:
            return node
            
    
    def visit_For(self, node: ast.For):
        if self.in_for_inserted:
            return node
        stmts: List[ast.stmt]
        stmts = node.body
        insert_in_for = ast.parse(self.insert_first_in_loop)
        body = insert_in_for.body
        stmts[0:0] = body
        self.in_for_inserted = True
        return node


do_before_loop = """oof = 2"""
do_in_loop = """
if not self.steps_dict is None:
    # print("OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO")
    self.steps_dict[step] = x.clone().detach().cpu().numpy().squeeze()
if not self.instrumentation_function is None:
    self.instrumentation_function(step, x.clone().detach().cpu().numpy().squeeze())
"""
do_before_return = """
if not self.steps_dict is None:
    self.steps_dict[steps] = x.clone().detach().cpu().numpy().squeeze()
if not self.instrumentation_function is None:
    self.instrumentation_function(steps, x.clone().detach().cpu().numpy().squeeze())
"""
augmented_function = "forward"

def alter_forward_function(method):
    source_code = inspect.getsource(method)
    source_code = textwrap.dedent(source_code)
    tree = ast.parse(source_code)
    #print(ast.dump(tree, indent=4))
    updated = ModelASTTransformer(augmented_function=augmented_function, insert_before_loop=do_before_loop, 
                                  insert_first_in_loop=do_in_loop, insert_before_return=do_before_return).visit(tree)
    updated = ast.increment_lineno(
        ast.fix_missing_locations(updated),
        method.__code__.co_firstlineno
    )

    ast.copy_location(updated.body[0], tree)

    # compile again, as a module, then execute the compiled bytecode and
    # extract the new function object. Use the original namespace
    # so that any global references in the function still work.
    code = compile(tree, inspect.getfile(method), 'exec')
    namespace = method.__globals__
    exec(code, namespace)
    new_function = namespace[method.__name__]
    return new_function



def forward_vis(method):
    source_code = inspect.getsource(method)
    source_code = textwrap.dedent(source_code)
    tree = ast.parse(source_code)
    #print(ast.dump(tree, indent=4))
    updated = ModelASTTransformer(augmented_function=augmented_function, insert_before_loop=do_before_loop, 
                                  insert_first_in_loop=do_in_loop, insert_before_return=do_before_return).visit(tree)
    updated = ast.increment_lineno(
        ast.fix_missing_locations(updated),
        method.__code__.co_firstlineno
    )

    ast.copy_location(updated.body[0], tree)

    # compile again, as a module, then execute the compiled bytecode and
    # extract the new function object. Use the original namespace
    # so that any global references in the function still work.
    code = compile(tree, inspect.getfile(method), 'exec')
    namespace = method.__globals__
    exec(code, namespace)
    new_function = namespace[method.__name__]

    # update new function with old function attributes, name, module, documentation
    # and attributes.
    return functools.update_wrapper(new_function, method)

"""
@forward_vis
def do_stuff():
    for i in range(3):
        print(i)
        
    return 3




class DummyClass():
    aaa = "EEEEEE"
    
    def mm(self):
        print("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM")
    @forward_vis
    def do_stuff(self):
        for i in range(3):
            print(i)
            
        return 3
    

if __name__ == '__main__':
    a = DummyClass()
    a.do_stuff()
"""